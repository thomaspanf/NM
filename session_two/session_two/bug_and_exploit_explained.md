# The exploit
- This is much less complicated than the logic bug. 
- When users call `depositEth()` the internal accounting updates to track the users shares
- Then the Ether that was deposited is sent to `depositAddress`
- But what happens if the caller _is_ `depositAddress`?
- They will never actually spend any money because it will go straight back to their wallet
- But they still get to keep and update the internal accounting for shares
- They can continue to call this to get a massive percentage of the shares without spending any Ether
- A malicious contract owner could call `depositEth` with their `depositAddress` for a massive value _just_ immediately before claiming starts and then easily be able to claim the majority of tokens with no risk or Ether spent. 

#The logic bug
The logic bug in this contract is related to how the function `claim()` distributes `vaultTokens` to depositors.
When all users have called `claim()` to claim their tokens, there are still `vaultToken`s belonging to the Challenge contract.
This is not the correct functionality, if all depositors claim their tokens then the balance of the Challenge contract should be empty.
### So how is this happening?
The contract must be giving out the incorrect amounts of tokens through `claim()` for this bug to happen so let's look there.
In these cases it's easier to work backwards from the issue
- The incorrect transfer amount is decided by the variable `userTokenBalance` so let's see how that's calculated
- The math `(percent * totalVaultTokenBalance) / 1000` is just a way to get a percentage of `totalVaultTokenBalance` provided that `percent` is correct, so we have a look at `percent`.
- Percent does its job correctly just by some simple math, let's say:
  ```
  // Our test values
  totalEth = 100
  balance = 10

  // We expect the percentage to be 10%
  percent = (balance * 1000) / totalEth
  percent = (10 * 1000) / 100
  percent = 100

  // Now let's run the percentage against some value fullAmount (let's choose 500) and see if we get 10% of that value (50)
  percentAmount = (percent * fullAmount) / 1000
  percentAmount = (100 * 500) / 1000
  percentAmount = 50

  // Therefore the percentage calculation is correct
  ```
- So it's not the percentage on first glance (there could be an edge case however, but your time would be better spent checking other things)
- We look back at how `userTokenBalance` is calculated and that leaves us with `totalVaultTokenBalance`, but that's just a reading of the current balance of the tokens in the contract? How could that be the problem?
- Remember that the percentage is a measurement of how much of the tokens should go to the user
- Notice that the balance is retreived every time this is called
- That means that every time `claim` is called, the value `totalVaultTokenBalance` will decrease
- So what happens is you get a percentage of the constantly shrinking `totalVaultTokenBalance` instead of the full amount at the begigging.
- The first user isn't affected, if they deserved 10% of the tokens then they will get it because no tokens have been retreived yet
- But following users who call `claim` will get a percentage of the original balance minus 10%, rather than a percentage of the original balance.
- You can see how I discovered this bug in the working section as I was testing the exploit above
